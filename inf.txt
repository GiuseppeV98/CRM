 wsl --install:
    installare wls per eseguire un amibiente linux necessario per installare la libreria django-auth-ldap

sudo apt update:
    Questo comando aggiorna l'indice dei pacchetti del tuo sistema operativo Linux.
    È un passaggio preliminare necessario per assicurarti che tu stia installando le versioni più recenti dei pacchetti disponibili.
 
installazione librerie necessarie libldap2-dev e libsasl2-dev
sudo apt install python3-pip python3-dev libldap2-dev libsasl2-dev libssl-dev:
    Questo comando installa vari pacchetti utili per lo sviluppo e l'esecuzione di applicazioni Python,
     in particolare quelle che interagiscono con server LDAP.

python3-pip:
    Il gestore dei pacchetti per Python, che ti permette di installare e gestire ulteriori librerie Python.

python3-dev:
    Questo pacchetto contiene gli header e le librerie di sviluppo per Python. È necessario per compilare alcune
     estensioni Python in C quando si installano pacchetti tramite pip.

libldap2-dev: 
    Fornisce gli header e le librerie di sviluppo per OpenLDAP. È essenziale per compilare pacchetti che richiedono 
    l'accesso a directory LDAP, come python-ldap.

libsasl2-dev: 
    Questo pacchetto include le librerie di sviluppo per l'autenticazione SASL (Simple Authentication and Security Layer), 
    che può essere utilizzata insieme a LDAP.
    
libssl-dev: 
    Include le librerie di sviluppo per SSL/TLS, necessarie per compilare molti pacchetti che utilizzano
    la crittografia o per comunicare in modo sicuro su reti.

pip install django-auth-ldap:



Configurazione in Django
    Aggiungi il backend di autenticazione LDAP alla tua configurazione di Django modificando il file settings.py:

    AUTHENTICATION_BACKENDS = [
        'django_auth_ldap.backend.LDAPBackend',
        'django.contrib.auth.backends.ModelBackend',  # Opzionale, per supporto utente locale
    ]


configurare il tuo server LDAP nel file settings.py.

    parametri principali da configurare:
    AUTH_LDAP_SERVER_URI: L'URI del tuo server LDAP.
    AUTH_LDAP_BIND_DN e AUTH_LDAP_BIND_PASSWORD: Per eseguire il bind al server LDAP.
        Questo valore è specifico per la configurazione del server LDAP e serve a 
        identificare l'utente che effettua la connessione al server LDAP. 
    AUTH_LDAP_USER_SEARCH: Un oggetto LDAPSearch per trovare gli utenti nel server LDAP.
         Questa specifica riga di codice definisce come Django dovrebbe cercare gli utenti nel tuo server LDAP. 
         

    Esempio di configurazione:
    import ldap
    from django_auth_ldap.config import LDAPSearch

    AUTH_LDAP_SERVER_URI = "ldap://ldap.example.com"
    AUTH_LDAP_BIND_DN = "cn=read-only-admin,dc=example,dc=com"
        cofigurazione common name e domanin component che rapprensenta il dominio nel quale l'utente esiste
    AUTH_LDAP_BIND_PASSWORD = "password"
    AUTH_LDAP_USER_SEARCH = LDAPSearch(
        "ou=users,dc=example,dc=com",
        ldap.SCOPE_SUBTREE,
        "(uid=%(user)s)"
    )
        Componenti di AUTH_LDAP_USER_SEARCH
            Base DN (ou=users,dc=example,dc=com):
                Questo è il Distinguished Name (DN) di base che indica la posizione nel tree LDAP da
                cui iniziare la ricerca degli utenti. In questo caso, la ricerca comincia nella Organizational Unit (OU)
                chiamata "users" all'interno del dominio "example.com".
            Scope della Ricerca (ldap.SCOPE_SUBTREE):
                Questo parametro determina il livello di profondità della ricerca all'interno del tree LDAP.
                ldap.SCOPE_SUBTREE significa che la ricerca sarà ricorsiva e includerà la OU specificata
                e tutte le sue sottodirectory. 
                Altre opzioni includono ldap.SCOPE_BASE, che cerca solo nel DN base,
                e ldap.SCOPE_ONELEVEL, che cerca solo un livello sotto il DN base.
            Filtro di Ricerca ("(uid=%(user)s)"):
                Questo è il filtro LDAP utilizzato per identificare l'utente specifico.
                Il filtro utilizza l'attributo uid (User ID), che è un identificatore comune per gli utenti nei sistemi LDAP.
                %(user)s è un placeholder che django-auth-ldap sostituirà con il nome utente fornito dall'utente 
                che sta tentando di autenticarsi. Questo filtro garantisce che solo l'oggetto 
                utente corrispondente a quel nome utente specifico verrà restituito.





Mappatura degli Attributi
    Puoi mappare gli attributi LDAP agli attributi del modello utente in Django:

    AUTH_LDAP_USER_ATTR_MAP = {
        "first_name": "givenName",
        "last_name": "sn",
        "email": "mail"
    }

Gestione della Connessione
    Per gestire le connessioni sicure, potresti voler configurare il tuo sistema per utilizzare TLS o SSL,
    o per validare i certificati del server LDAP:

    AUTH_LDAP_START_TLS = True

Gruppi e Permessi
Puoi configurare Django per mappare i gruppi LDAP ai gruppi di utenti Django,
permettendo di gestire permessi basati sui gruppi LDAP:

AUTH_LDAP_GROUP_SEARCH = LDAPSearch(
    "ou=django,ou=groups,dc=example,dc=com",
    ldap.SCOPE_SUBTREE,
    "(objectClass=groupOfNames)"
)
AUTH_LDAP_GROUP_TYPE = GroupOfNamesType(name_attr="cn")




asgiref==3.7.2
cffi==1.16.0
colorama==0.4.6
cryptography==42.0.5
Django==5.0.3
django-appconf==1.0.6
django-cryptography==1.1
django-environ==0.11.2
django-otp==1.3.0
mysqlclient==2.2.4
pillow==10.2.0
pycparser==2.21
pyotp==2.9.0
pypng==0.20220715.0
python-decouple==3.8
qrcode==7.4.2
sqlparse==0.4.4
typing_extensions==4.10.0
tzdata==2024.1
django-python3-ldap==0.15.6





from django.shortcuts import redirect
from django.urls import resolve
from two_factor_auth.models import UserProfile
from django.http import HttpResponseRedirect
from django.urls import reverse

class TwoFactorAuthMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        response = self.get_response(request)

        if request.user.is_authenticated:
            try:
                profile = UserProfile.objects.get(user=request.user)
                current_url_name = resolve(request.path).url_name
                # Verifica se il token di sessione corrisponde
                session_token = request.session.get('session_token')
                if profile.session_token != session_token:
                    # Se il token non corrisponde, effettua il logout
                    return redirect('two_factor_auth:logout')

                if request.session.get('verified_2fa', False) and current_url_name in ['generate_qr', 'verify_otp','verify_backup']:
                    return redirect('dashboard:homepage')

                if current_url_name != 'homepage' and request.session.get('verified_2fa', False):
                # Se l'utente ha verificato l'OTP, non dovrebbe essere reindirizzato altrove.
                    return response
                # Assicurati che l'utente completi la configurazione 2FA prima di accedere alla homepage
                if current_url_name == 'homepage':
                    if not request.session.get('verified_2fa', False):
                        # Reindirizza a generate_qr o verify_otp in base alla configurazione del segreto 2FA
                        if not profile.two_factor_secret:
                            return redirect('two_factor_auth:generate_qr')
                        else:
                            return redirect('two_factor_auth:verify_otp')

                # Gestisci il flusso tra la generazione del QR e la verifica OTP
                
                if current_url_name == 'generate_qr':
                    if profile.two_factor_secret and not request.session.get('two_factor_token'):
                    # Accesso a generate_qr solo se esiste un token nella sessione
                        # Senza token, reindirizza a verify_otp
                        return redirect('two_factor_auth:verify_otp')
                    
            except UserProfile.DoesNotExist:
                return redirect('auth:logout')

        return response




        def user_login(request):
    form = AuthenticationForm(request, data=request.POST or None)
    if request.user.is_authenticated:
        return redirect('two_factor_auth:verify_otp')

    if request.method == 'POST':
        email = request.POST.get('username')
        password = request.POST.get('password')
        user_attempt = Authorization.objects.filter(username=email).first()#User
        if user_attempt:
            try:
                profile, _ = Authorization.objects.get_or_create(user=user_attempt)#UserProfile
            except Exception as e:
                return render(request, 'login.html', {'form': form})

            if not profile.can_attempt_login():
                form.add_error(None, "Troppi tentativi di accesso falliti. Riprova più tardi.")
                return render(request, 'login.html', {'form': form})
            
            user = authenticate(username=email, password=password)
            if user:
                login(request, user)  # Assicurati di fare il login prima di manipolare la sessione
                request.session.cycle_key()

                profile.reset_failed_login_attempts()  # Reset dei tentativi falliti
                profile.last_check_token= timezone.now()
                profile.save()              #aggiorno solo il last_check_token al primo accesso ---------------------
                if not profile.two_factor_secret:
                    return redirect('two_factor_auth:generate_qr')
                else:
                    request.session['verified_2fa'] = False  # Resetta il flag di verifica
                    return redirect('two_factor_auth:verify_otp')
            else:
                profile.register_failed_login()  # Registra il tentativo fallito

    return render(request, 'login.html', {'form': form})










# Verifica il token di sessione
                current_session_token = profile.session_token
                if 'session_token' in request.session and current_session_token == request.session['session_token']:
                    logout(request)  # Forza il logout dalla sessione corrente
                else:
                    login(request, user)
                    request.session.cycle_key()
                    profile.reset_failed_login_attempts()  # Reset dei tentativi falliti
                    if not profile.two_factor_secret:
                        return redirect('two_factor_auth:generate_qr')
                    else:
                        request.session['verified_2fa'] = False  # Resetta il flag di verifica
                        # Genera un nuovo token di sessione
                        session_token = secrets.token_urlsafe()
                        # Salva il token nel profilo utente
                        profile.session_token = session_token
                        profile.save()
                        # Imposta il token nella sessione dell'utente
                        request.session['session_token'] = session_token
                        return redirect('two_factor_auth:verify_otp')








@login_required
def verify_otp(request):
    form = OTPForm(request.POST or None)
    if request.method == 'POST' and form.is_valid():
        profile = UserProfile.objects.get(user=request.user)
        totp = pyotp.TOTP(profile.two_factor_secret)
        if totp.verify(form.cleaned_data['otp_code']):
            # Se è la prima configurazione del 2FA, invia i codici di backup
            if 'two_factor_token' in request.session:
                request.session.pop('two_factor_token', None)
            # Se il codice OTP è corretto, imposta il flag di verifica nella sessione.
            
            request.session['verified_2fa'] = True
            return redirect('dashboard:homepage')
        else:
            # Se il codice OTP non è corretto, mostra un errore.
            form.add_error('otp_code', 'Codice OTP non valido.')
            
    # Se il metodo non è POST o il form non è valido, mostra semplicemente la pagina.
    return render(request, 'verify_otp.html', {'form': form})





    mssql-django:
    python -m pip install pyodbc
    pip install mssql-django
    
       DATABASES = {
        'default': {
            'ENGINE': 'mssql',
            'NAME': 'mydb',
            'USER': 'user@myserver',
            'PASSWORD': 'password',
            'HOST': 'myserver.database.windows.net',
            'PORT': '',

            'OPTIONS': {
                'driver': 'ODBC Driver 17 for SQL Server',
            },
        },
    }

    # set this to False if you want to turn off pyodbc's connection pooling
    DATABASE_CONNECTION_POOLING = False


    DATABASE_URL=mysql://root:Peppe1998!@localhost:3306/utentiaut


from ldap3 import Server, Connection, ALL

ldap_server = '192.168.1.2'  
ldap_port = 389
user_email = 'TestLdap@corporate.it' 
user_password = 'T3st@Ld4p'  

try:
    server = Server(ldap_server, port=ldap_port, get_info=ALL)
    conn = Connection(server,
                      user=user_email,  
                      password= user_password,
                      auto_bind=True)
    
    if conn.bind():
        print("Autenticazione al server LDAP riuscita.")
    else:
        print("Autenticazione al server LDAP fallita.")
except Exception as e:
    print(f"Errore nell'autenticazione al server LDAP: {e}")

    import pyodbc


    49730



        if request.user.is_authenticated:
        
            profile = UserProfile.objects.get(user=request.user)
            current_url_name = resolve(request.path).url_name
            # Verifica se il token di sessione corrisponde
            session_token = request.session.get('session_token')
            if request.session.get('verified_2fa', False):
                if profile.session_token != session_token:
            
            # Solo se l'utente ha verificato 2FA e il token non corrisponde, effettua il logout
                    return redirect('two_factor_auth:logout')

            if request.session.get('verified_2fa', False) and current_url_name in ['generate_qr', 'verify_otp','verify_backup']:
                return redirect('dashboard:homepage')

            if current_url_name != 'homepage' and request.session.get('verified_2fa', False):
            # Se l'utente ha verificato l'OTP, non dovrebbe essere reindirizzato altrove.
                return response
            # Assicurati che l'utente completi la configurazione 2FA prima di accedere alla homepage
            if current_url_name == 'homepage':
                if not request.session.get('verified_2fa', False):
                    # Reindirizza a generate_qr o verify_otp in base alla configurazione del segreto 2FA
                    if not profile.two_factor_secret:
                        return redirect('two_factor_auth:generate_qr')
                    else:
                        return redirect('two_factor_auth:verify_otp')

            # Gestisci il flusso tra la generazione del QR e la verifica OTP
            
            if current_url_name == 'generate_qr':
                if profile.two_factor_secret and not request.session.get('two_factor_token'):
                # Accesso a generate_qr solo se esiste un token nella sessione
                    # Senza token, reindirizza a verify_otp
                    return redirect('two_factor_auth:verify_otp')


DATABASES = {
    'default': {
        'ENGINE': 'mssql',
        'NAME': 'prova_sqls',
        'USER': 'sa',
        'PASSWORD': 'Peppe1998!',
        'HOST': 'LAPTOP-IEQV8TAD\SQLEXPRESS',  # Assicurati che questo sia corretto
        'PORT': '1433',
        'OPTIONS': {
            'driver': 'ODBC Driver 17 for SQL Server',
            'TrustServerCertificate': 'yes',
        },
    },
}




from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from users.models import UserProfile

@csrf_exempt
def verify_token(request):
    if request.method == 'POST':
        token_value = request.POST.get('token')
    elif request.method == 'GET':
        token_value = request.GET.get('token')
    else:
        return JsonResponse({'error': 'Invalid request method'}, status=400)

    if UserProfile.objects.filter(session_token=token_value).exists():
        return JsonResponse({'status': 'valid'})
    else:
        return JsonResponse({'status': 'invalid'})



@csrf_exempt
@login_required
def verify_token(request):
    token_value = None

    if request.method == 'POST':
        token_value = request.POST.get('token') 
    elif request.method == 'GET':
        token_value = request.GET.get('token') 
    else:
        return HttpResponse('Invalid request method', status=400)

    if token_value and UserProfile.objects.filter(session_token=token_value).exists():
        profile = UserProfile.objects.get(user=request.user)
        #tempo_corrente = timezone.now()
        tempo_valido = profile.last_check_token  + timedelta(minutes=30)
        profile.last_check_token 
        if tempo_corrente <= tempo_valido:
            profile.last_check_token = timezone.now()  # Aggiorna last_check_token con l'ora corrente
            profile.save()
            return HttpResponse(True)
        else:
            return HttpResponse(False, status=403) 
    else:
        return HttpResponse(False)


@csrf_exempt
def verify_token(request):
    token_value = None

    if request.method == 'POST':
        token_value = request.POST.get('token') or request.headers.get('Authorization')
    elif request.method == 'GET':
        token_value = request.GET.get('token') or request.headers.get('Authorization')
    else:
        return HttpResponse('Invalid request method', status=400)

    if token_value and UserProfile.objects.filter(session_token=token_value).exists():
        return HttpResponse('valid')
    else:
        return HttpResponse('invalid')




          
            profile = UserProfile.objects.get(user=request.user)
            current_url_name = resolve(request.path).url_name
            # Verifica se il token di sessione corrisponde
            session_token = request.session.get('session_token')
            if request.session.get('verified_2fa', False):
                if profile.session_token != session_token:
            
            # Solo se l'utente ha verificato 2FA e il token non corrisponde, effettua il logout
                    return redirect('two_factor_auth:logout')



                    @csrf_exempt
def verify_token(request):
    token_value = None

    if request.method == 'POST':
        token_value = request.POST.get('token')
    elif request.method == 'GET':
        token_value = request.GET.get('token')
    else:
        return HttpResponse('Invalid request method', status=400)

    if token_value and UserProfile.objects.filter(session_token=token_value).exists():
        profile = UserProfile.objects.get(session_token=token_value)
        tempo_corrente = timezone.now()
        tempo_valido = profile.last_check_token + timedelta(minutes=10) #if profile.last_check_token else timezone.now()
        
        if tempo_corrente <= tempo_valido:
            profile.last_check_token = timezone.now()  # Aggiorna last_check_token con l'ora corrente
            profile.save()
            return HttpResponse('True')
        else:
            return HttpResponse('False', status=403)
    else:
        return HttpResponse('False', status=404)

if request.user.is_authenticated:
        
            profile = UserProfile.objects.get(user=request.user)
            current_url_name = resolve(request.path).url_name
            tempo_corrente = timezone.now()
            tempo_valido = profile.last_check_token + timedelta(minutes=10)
            if tempo_corrente>=tempo_valido:
                return redirect('two_factor_auth:logout')
            # Verifica se il token di sessione corrisponde
           
            if request.session.get('verified_2fa', False): #and two_factor==profile.get_two_factor():
                two_factor = signing.loads(request.session.get('token_2fa'))
                if two_factor==profile.get_two_factor():
                    session_token = request.session.get('session_token')
                    stored_token = profile.get_session_token()
                    #if session_token:
                    try:
                        session_token = signing.loads(session_token)
                    except signing.BadSignature:
                        session_token = None
                    if  stored_token != session_token:  #and tempo_corrente<=tempo_valido:   #stored_token and
                        return redirect('two_factor_auth:logout')

            if (request.session.get('verified_2fa', False)) and current_url_name in ['generate_qr', 'verify_otp','verify_backup']:
                return redirect ('dashboard:homepage')
                #('https://crm.adncallcenter.net/default.asp')# and two_factor==profile.get_two_factor()
            if current_url_name != 'homepage' and request.session.get('verified_2fa', False):
            # Se l'utente ha verificato l'OTP, non dovrebbe essere reindirizzato altrove.
                return response
            # Assicurati che l'utente completi la configurazione 2FA prima di accedere alla homepage
            if current_url_name == 'homepage':
                if not request.session.get('verified_2fa', False):
                    # Reindirizza a generate_qr o verify_otp in base alla configurazione del segreto 2FA
                    if not profile.two_factor_secret:
                        return redirect('two_factor_auth:generate_qr')
                    else:
                        return redirect('two_factor_auth:verify_otp')

            # Gestisci il flusso tra la generazione del QR e la verifica OTP
            
            #if current_url_name == 'generate_qr':
                #if profile.two_factor_secret and not request.session.get('two_factor_token'):
                # Accesso a generate_qr solo se esiste un token nella sessione
                    # Senza token, reindirizza a verify_otp
                    #return redirect('two_factor_auth:verify_otp')



@ensure_csrf_cookie
def user_login(request):
    if request.method == 'POST':
        try:
            data = json.loads(request.body.decode('utf-8'))
            username = data.get('username')
            password = data.get('password')
            user_attempt = User.objects.filter(username=username).first()
            print(f"user_attempt: {user_attempt}")

            if user_attempt:
                profile, _ = UserProfile.objects.get_or_create(user=user_attempt)
                if not profile.can_attempt_login():
                    return JsonResponse({'error': 'Troppi tentativi di accesso falliti. Riprova più tardi.'}, status=403)
                
                user = authenticate(username=username, password=password)
                if user:
                    login(request, user)
                    request.session.cycle_key()
                    profile.reset_failed_login_attempts()
                    profile.last_check_token = timezone.now()
                    profile.save()
                    print("Login successful, user logged in")

                    if not profile.two_factor_secret:
                        return JsonResponse({'redirect': 'generate_qr'}, status=200)
                    else:
                        request.session['verified_2fa'] = False
                        return JsonResponse({'redirect': 'verify_otp'}, status=200)
                else:
                    profile.register_failed_login()
                    return JsonResponse({'error': 'Credenziali non valide'}, status=401)
            else:
                print("User not found")
                return JsonResponse({'error': 'Utente non trovato'}, status=404)
        except json.JSONDecodeError:
            return JsonResponse({'error': 'Invalid JSON'}, status=400)

    elif request.method == 'GET':
        # Rispondi con uno status di successo o un messaggio che conferma che la pagina di login è accessibile
        return JsonResponse({'status': 'success', 'message': 'Login page accessible'}, status=200)
    
    else:
        return JsonResponse({'status': 'error', 'message': 'Metodo non permesso'}, status=405)
    #return JsonResponse({'error': 'Metodo non permesso'}, status=405)


 <div className="container" id= "container">
          <div className="row justify-content-center">
            <div className="col-md-8 col-lg-6">
              <div id="logo-container" className="text-center mb-4">
                <img src="/images/adn_Piccolo.gif" id="imglogin" alt="Cuffie" />
              </div>
              <div id="login-form" className="p-4 border rounded">
                <h2 className="mb-4">Login</h2>
                {error && <div className="alert alert-danger">{error}</div>}
                <form onSubmit={(e) => handleSubmit(e, username, password)}>
                  <div className="form-group mb-3">
                    <label htmlFor="username">Username:</label>
                    <input
                      type="text"
                      className="form-control"
                      id="username"
                      value={username}
                      onChange={(e) => setUsername(e.target.value)}
                      required
                    />
                  </div>
                  <div className="form-group mb-3">
                    <label htmlFor="password">Password:</label>
                    <input
                      type="password"
                      className="form-control"
                      id="password"
                      value={password}
                      onChange={(e) => setPassword(e.target.value)}
                      required
                    />
                  </div>
                  <button type="submit" className="btn btn-primary btn-block">
                    Login
                  </button>
                </form>
              </div>
            </div>
          </div>
        </div>




<div className="container mt-5" id="containerVerify">
            {redirectData && <RedirectForm {...redirectData} />}
            <div className="row justify-content-center">
                <div className="col-md-12 col-lg-6 col-sl-3">
                    <div className="text-center">
                        <h2>Verifica OTP</h2>
                    </div>
                    <div className="p-4 border rounded container" id="login-formVerify">
                        {error && <div className="alert alert-danger">{error}</div>}
                        <form onSubmit={handleSubmit}>
                            <div className="form-group">
                                <label htmlFor="otpCode">OTP Code:</label>
                                <input
                                    type="text"
                                    className="form-control"
                                    id="otpCode"
                                    value={otpCode}
                                    onChange={e => setOtpCode(e.target.value)}
                                    required
                                />
                            </div>
                            <button type="submit" className="btn btn-primary btn-block">Verify</button>
                        </form>
                        <div className="backup-option text-center mt-3">
                            <p>Non hai con te il cellulare? Accedi tramite Email</p>
                            <button onClick={handleNavigateToBackup} className="btn btn-link">Usa il Codice di Backup</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

















// LoginForm.jsx
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import axios from './AxiosConfig';
import Cookies from 'js-cookie';
import 'bootstrap/dist/css/bootstrap.min.css';

const LoginForm = () => {
    const [username, setUsername] = useState('');
    const [password, setPassword] = useState('');
    const navigate = useNavigate();
    const [error, setError] = useState('');

    useEffect(() => {
        axios.defaults.headers.common['X-CSRFToken'] = Cookies.get('csrftoken');
    }, []);

    const handleLogin = async (username, password) => {
        try {
            const response = await axios.post('http://172.23.149.57:8000/auth/login/', {
                username: username,
                password: password,
            });

            if (response.data.redirect) {
                if (response.data.redirect === 'generate_qr') {
                    navigate('/generate_qr_code ');
                } else if (response.data.redirect === 'verify_otp') {
                    navigate('/verify_otp');
                } else if (response.data.redirect === 'dashboard') {
                    navigate('/dashboard');
                }
            }
        } catch (error) {
            console.error('Error during login:', error);
            if (error.response && error.response.data && error.response.data.error) {
                setError(error.response.data.error);
            } else {
                setError('An unexpected error occurred.');
            }
        }
    };

    const handleSubmit = (event) => {
        event.preventDefault();
        handleLogin(username, password);
    };

    return (
      
      <div className="container" id= "container">
        <div class="row justify-content-center" id = "login">
    <div class="col-4" id= "lato_logo">
    <div id="logo-container" className="text-center mb-4">
                <img src="/images/adn_Piccolo.gif" id="imglogin" alt="Cuffie" />
    </div>
     
    </div>
    <div class="col-4" id="lato_form">
    <div id="login-form" className="p-4 border rounded">
                <h2 className="mb-4">Login</h2>
                {error && <div className="alert alert-danger">{error}</div>}
                <form onSubmit={(e) => handleSubmit(e, username, password)}>
                  <div className="form-group mb-3">
                    <label htmlFor="username">Username:</label>
                    <input
                      type="text"
                      className="form-control"
                      id="username"
                      value={username}
                      onChange={(e) => setUsername(e.target.value)}
                      required
                    />
                  </div>
                  <div className="form-group mb-3">
                    <label htmlFor="password">Password:</label>
                    <input
                      type="password"
                      className="form-control"
                      id="password"
                      value={password}
                      onChange={(e) => setPassword(e.target.value)}
                      required
                    />
                  </div>
                  <button type="submit" className="btn btn-primary btn-block">
                    Login
                  </button>
                </form>
              </div>

    </div>
  </div>
        
GenerateQrCode,jsx 
        </div>
      );      
}

export default LoginForm;

import React, { useState, useEffect } from 'react';
import axios from './AxiosConfig';
import { useNavigate } from 'react-router-dom';
import { Container, Row, Col, Alert, Button } from 'react-bootstrap';
import 'bootstrap/dist/css/bootstrap.min.css';

const GenerateQrCode = () => {
  const [qrImage, setQrImage] = useState(null);
  const [error, setError] = useState(null);
  const navigate = useNavigate();

  useEffect(() => {
    const fetchQrCode = async () => {
      try {
        const response = await axios.get('/auth/generate_qr/');
        if (response.data.qr_image_base64) {
          setQrImage(response.data.qr_image_base64);
        } else {
          navigate('/verify_otp');
        }
      } catch (error) {
        setError('An unexpected error occurred while fetching the QR code.');
        console.error('Error fetching QR code:', error);
      }
    };

    fetchQrCode();
  }, [navigate]);

  return (
    <Container className="mt-5">
      <Row className="justify-content-center">
        <Col md={8} lg={6} className="text-center">
          <h2>Scan the QR Code</h2>
          {error && <Alert variant="danger">{error}</Alert>}
          {qrImage ? (
            <>
              <img src={`data:image/png;base64,${qrImage}`} alt="QR Code" style={{ maxWidth: '100%', height: 'auto' }} />
              <Button variant="primary" className="mt-3" onClick={() => navigate('/verify_otp')}>Proceed to Verify OTP</Button>
            </>
          ) : (
            <p>Loading QR code...</p>
          )}
        </Col>
      </Row>
    </Container>
  );
};

export default GenerateQrCode;

// src/components/VerifyOtpForm.jsx
import React, { useState, useEffect } from 'react';
import axios from './AxiosConfig';
import Cookies from 'js-cookie';
import RedirectForm from './RedirectForm';
import { useNavigate } from 'react-router-dom';

const VerifyOtpForm = () => {
    const [otpCode, setOtpCode] = useState('');
    const [error, setError] = useState('');
    const [redirectData, setRedirectData] = useState(null);
    const navigate = useNavigate();
    const [limit, setLimit] = useState(0);

    useEffect(() => {
        axios.defaults.headers.common['X-CSRFToken'] = Cookies.get('csrftoken');
    }, []);

    const handleVerifyOtp = async () => {
        try {
            const response = await axios.post('http://172.23.149.57:8000/auth/verify_otp/', { otp_code: otpCode });
            console.log("Risposta dal server:", response.data);
            
            if (response.data.status === 'success') {
                const url_asp = 'https://crm.adncallcenter.net/training/defaultnew.asp'
                if (response.data.redirect===url_asp) {
                    setRedirectData({
                        url: response.data.redirect,
                        session_token: response.data.session_token,
                        user: response.data.user,
                        password:response.data.password
                    });
                } else {
                    navigate(response.data.redirect); // Per percorsi relativi
                }
            } else {
                setError('OTP non valido.');
            }
        } catch (error) {
            console.error("Errore durante la verifica dell'OTP:", error);
            setError('Errore durante la verifica dell\'OTP.');
        }
    };


    const handleNavigateToBackup = async () => {
        if(limit===0)
        {
            setLimit(1);
            try {
                await axios.get('/auth/send_otp_and_redirect/');
                navigate('/verify_backup');
            } catch (error) {
                setError('Errore durante l\'invio dell\'OTP.');
            }
        setLimit(0);
        }

        
    };

    const handleSubmit = (event) => {
        event.preventDefault();
        handleVerifyOtp();
    };

    return (
        <div className="container" id= "container">
        <div class="row justify-content-center" id = "login">
    <div class="col-4" id= "lato_logo">
    <div id="logo-container" className="text-center mb-4">
                <img src="/images/adn_Piccolo.gif" id="imglogin" alt="Cuffie" />
    </div>
     
    </div>
    <div class="col-4" id="lato_form">
    {redirectData && <RedirectForm {...redirectData} />}
            <div className="row justify-content-center">
                <div className="col-md-12 col-lg-6 col-sl-3">
                    <div className="text-center">
                        <h2>Verifica OTP</h2>
                    </div>
                    <div className="p-4 border rounded container" id="login-formVerify">
                        {error && <div className="alert alert-danger">{error}</div>}
                        <form onSubmit={handleSubmit}>
                            <div className="form-group">
                                <label htmlFor="otpCode">OTP Code:</label>
                                <input
                                    type="text"
                                    className="form-control"
                                    id="otpCode"
                                    value={otpCode}
                                    onChange={e => setOtpCode(e.target.value)}
                                    required
                                />
                            </div>
                            <button type="submit" className="btn btn-primary btn-block">Verify</button>
                        </form>
                        <div className="backup-option text-center mt-3">
                            <p>Non hai con te il cellulare?</p>
                            <p> Accedi tramite Email</p>
                            <button onClick={handleNavigateToBackup} className="btn btn-link">Usa il Codice di Backup</button>
                        </div>
                    </div>
                </div>
            </div>

    </div>
  </div>
        
        
        
        </div>
            );
};

export default VerifyOtpForm;

questi sono i componenti che verranno collegati al componente principale, creami il componente principale che mostrerà i componenti che ti ho mostrato 

